------ Upstream Registry and Configuration ---------------------------------------------------
CREATE TABLE IF NOT EXISTS UPSTREAM_REGISTRY(
  ID TEXT PRIMARY KEY DEFAULT (HEX(RANDOMBLOB(16))),
  NAME TEXT NOT NULL UNIQUE CHECK(LENGTH(NAME) BETWEEN 3 AND 255),
  DESCRIPTION TEXT NOT NULL CHECK(LENGTH(DESCRIPTION) <= 1000),
  VENDOR TEXT NOT NULL CHECK(VENDOR IN (
    'docker_hub', 'gcr', 'ecr', 'acr', 'ghcr', 'gitlab', 
    'quay', 'harbor', 'artifactory', 'nexus', 'custom'
  )),
  STATE TEXT NOT NULL DEFAULT 'active' CHECK(STATE IN ('active', 'deprecated', 'disabled')),
  PORT INTEGER NOT NULL UNIQUE CHECK(PORT BETWEEN 1025 AND 65535),
  UPSTREAM_URL TEXT NOT NULL CHECK(
    UPSTREAM_URL LIKE 'http%' AND 
    LENGTH(UPSTREAM_URL) <= 2048
  ),
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DROP TRIGGER IF EXISTS trg_update_upstream_registry;
CREATE TRIGGER trg_update_upstream_registry
BEFORE UPDATE ON UPSTREAM_REGISTRY
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

CREATE TABLE IF NOT EXISTS UPSTREAM_REGISTRY_AUTH_CONFIG (
  REGISTRY_ID TEXT NOT NULL,
  AUTH_TYPE TEXT NOT NULL CHECK(AUTH_TYPE IN (
    'anonymous', 'basic', 'bearer', 'oauth2',
    'aws_ecr', 'gcp_service_account', 'azure_service_principal',
    'harbor_robot', 'artifactory_token', 'gitlab_token', 'github_token'
  )),
  CONFIG_JSON BLOB NOT NULL, -- Should always have config, even if empty {}
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE,
  UNIQUE(REGISTRY_ID)
);

DROP TRIGGER IF EXISTS trg_update_upstream_registry_auth_config;
CREATE TRIGGER trg_update_upstream_registry_auth_config
BEFORE UPDATE ON UPSTREAM_REGISTRY_AUTH_CONFIG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY_AUTH_CONFIG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

CREATE TABLE IF NOT EXISTS UPSTREAM_REGISTRY_CACHE_STORAGE_CONFIG (
  REGISTRY_ID TEXT NOT NULL,
  CACHE_ENABLED INTEGER NOT NULL DEFAULT 0 CHECK(CACHE_ENABLED IN (0, 1)),
  TTL_SECONDS INTEGER NOT NULL DEFAULT 3600 CHECK(TTL_SECONDS BETWEEN 60 AND 2592000),

  STORAGE_LIMIT REAL DEFAULT 100 CHECK(STORAGE_LIMIT >= 1),
  CLEANUP_THRESHOLD_PERCENTAGE REAL NOT NULL DEFAULT 80.0 CHECK(
    CLEANUP_THRESHOLD_PERCENTAGE BETWEEN 50.0 AND 95.0
  ),
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE,
  UNIQUE(REGISTRY_ID)
);

DROP TRIGGER IF EXISTS trg_update_upstream_registry_cache_config;
CREATE TRIGGER trg_update_upstream_registry_cache_config
BEFORE UPDATE ON UPSTREAM_REGISTRY_CACHE_STORAGE_CONFIG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY_CACHE_STORAGE_CONFIG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

CREATE TABLE IF NOT EXISTS UPSTREAM_REGISTRY_NETWORK_CONFIG(
  REGISTRY_ID TEXT NOT NULL,

  -- Timeouts
  CONNECTION_TIMEOUT INTEGER NOT NULL DEFAULT 10 CHECK(CONNECTION_TIMEOUT BETWEEN 1 AND 300),
  READ_TIMEOUT INTEGER NOT NULL DEFAULT 30 CHECK(READ_TIMEOUT BETWEEN 1 AND 600),
  WRITE_TIMEOUT INTEGER NOT NULL DEFAULT 30 CHECK(WRITE_TIMEOUT BETWEEN 1 AND 600),
  
  -- Connection pooling
  MAX_CONNECTIONS INTEGER NOT NULL DEFAULT 100 CHECK(MAX_CONNECTIONS BETWEEN 1 AND 1000),
  MAX_IDLE_CONNECTIONS INTEGER NOT NULL DEFAULT 10 CHECK(MAX_IDLE_CONNECTIONS BETWEEN 1 AND 100),
  
  -- Retry logic
  MAX_RETRIES INTEGER NOT NULL DEFAULT 3 CHECK(MAX_RETRIES BETWEEN 0 AND 10),
  RETRY_DELAY INTEGER NOT NULL DEFAULT 5 CHECK(RETRY_DELAY BETWEEN 1 AND 60),
  RETRY_BACKOFF_MULTIPLIER REAL NOT NULL DEFAULT 2.0 CHECK(RETRY_BACKOFF_MULTIPLIER BETWEEN 1.0 AND 5.0),

  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE,
  UNIQUE(REGISTRY_ID)
);

DROP TRIGGER IF EXISTS trg_update_upstream_registry_network_config;
CREATE TRIGGER trg_update_upstream_registry_network_config
BEFORE UPDATE ON UPSTREAM_REGISTRY_NETWORK_CONFIG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY_NETWORK_CONFIG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

---------------- End of Upstream Registry and config -----------------------------------------------

----------------- Namespace and Repository ---------------------------------------------------------

CREATE TABLE IF NOT EXISTS REGISTRY_NAMESPACE (
  REGISTRY_ID TEXT NOT NULL,
  NAME TEXT NOT NULL,
  DESCRIPTION TEXT NOT NULL,
  PURPOSE TEXT NOT NULL,
  IS_PUBLIC INT DEFAULT 0,
  STATE TEXT NOT NULL DEFAULT 'Active'
  ID TEXT PRIMARY KEY DEFAULT (HEX(RANDOMBLOB(16))),
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(REGISTRY_ID, NAME),
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS REGISTRY_REPOSITORY (
  ID TEXT PRIMARY KEY DEFAULT (HEX(RANDOMBLOB(16))),
  NAME TEXT NOT NULL,
  DESCRIPTION TEXT,
  IS_PUBLIC INT DEFAULT 0,
  STATE TEXT NOT NULL DEFAULT 'Active',
  NAMESPACE_ID TEXT NOT NULL,
  REGISTRY_ID TEXT NOT NULL,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (REGISTRY_ID, NAMESPACE_ID, NAME),
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE,
  FOREIGN KEY (NAMESPACE_ID) REFERENCES REGISTRY_NAMESPACE(ID) ON DELETE CASCADE
);

--------------- End of Namespace and Repository ----------------------------------------------------------

--------------- Image blob, manifest, tag and mapping -----------------------------------------------

CREATE TABLE IF NOT EXISTS IMAGE_BLOB_META (
  NAMESPACE_ID TEXT NOT NULL,
  REGISTRY_ID TEXT NOT NULL,
  REPOSITORY_ID TEXT NOT NULL,
  BLOB_DIGEST TEXT NOT NULL,
  SIZE INTEGER NOT NULL,
  LOCATION TEXT NOT NULL UNIQUE,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (REGISTRY_ID, NAMESPACE_ID, REPOSITORY_ID, BLOB_DIGEST),
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE,
  FOREIGN KEY (NAMESPACE_ID) REFERENCES REGISTRY_NAMESPACE(ID) ON DELETE CASCADE,
  FOREIGN KEY (REPOSITORY_ID) REFERENCES REGISTRY_REPOSITORY(ID) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS IMAGE_TAG (
  NAMESPACE_ID TEXT NOT NULL,
  REGISTRY_ID TEXT NOT NULL,
  REPOSITORY_ID TEXT NOT NULL,
  IS_STABLE INT DEFAULT 0,
  ID TEXT PRIMARY KEY DEFAULT (HEX(RANDOMBLOB(16))),
  TAG TEXT NOT NULL,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (REGISTRY_ID, NAMESPACE_ID, REPOSITORY_ID, TAG),
  FOREIGN KEY (REPOSITORY_ID) REFERENCES REGISTRY_REPOSITORY(ID) ON DELETE CASCADE,
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE,
  FOREIGN KEY (NAMESPACE_ID) REFERENCES REGISTRY_NAMESPACE(ID) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS IMAGE_MANIFEST_TAG_MAPPING (
  MANIFEST_ID  TEXT NOT NULL UNIQUE,
  TAG_ID TEXT NOT NULL UNIQUE
);

-- For the cached manifest, DIGEST = UNIQUE_DIGEST
-- For the hosted manifest, DIGEST != UNIQUE_DIGEST
CREATE TABLE IF NOT EXISTS IMAGE_MANIFEST (
  ID TEXT PRIMARY KEY DEFAULT (HEX(RANDOMBLOB(16))), 
  DIGEST TEXT NOT NULL,
  SIZE INTEGER NOT NULL,
  MEDIA_TYPE TEXT NOT NULL,
  MANIFEST_CONTENT BLOB NOT NULL,
  NAMESPACE_ID TEXT NOT NULL,
  REGISTRY_ID TEXT NOT NULL,
  REPOSITORY_ID TEXT NOT NULL,
  UNIQUE_DIGEST TEXT NOT NULL, 
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (REGISTRY_ID, NAMESPACE_ID, REPOSITORY_ID, UNIQUE_DIGEST),
  FOREIGN KEY (REPOSITORY_ID) REFERENCES REGISTRY_REPOSITORY(ID) ON DELETE CASCADE,
  FOREIGN KEY (REGISTRY_ID) REFERENCES UPSTREAM_REGISTRY(ID) ON DELETE CASCADE,
  FOREIGN KEY (NAMESPACE_ID) REFERENCES REGISTRY_NAMESPACE(ID) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS IMAGE_REGISTRY_CACHE (
  NAMESPACE_ID TEXT NOT NULL,
  REGISTRY_ID TEXT NOT NULL,
  REPOSITORY_ID TEXT NOT NULL,
  IDENTIFIER TEXT NOT NULL,
  DIGEST TEXT NOT NULL,
  EXPIRES_AT TIMESTAMP NOT NULL,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

------------------------------------------------------------------------------------------------------------
-- Triggers to auto-update UPDATED_AT on changes
------------------------------------------------------------------------------------------------------------

-- Trigger for UPSTREAM_REGISTRY table
DROP TRIGGER IF EXISTS trg_update_upstream_registry;
CREATE TRIGGER trg_update_upstream_registry
BEFORE UPDATE ON UPSTREAM_REGISTRY
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for UPSTREAM_REGISTRY_AUTH_CONFIG table
DROP TRIGGER IF EXISTS trg_update_upstream_registry_auth_config;
CREATE TRIGGER trg_update_upstream_registry_auth_config
BEFORE UPDATE ON UPSTREAM_REGISTRY_AUTH_CONFIG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY_AUTH_CONFIG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for UPSTREAM_REGISTRY_ACCESS_CONFIG table
DROP TRIGGER IF EXISTS trg_update_upstream_registry_access_config;
CREATE TRIGGER trg_update_upstream_registry_access_config
BEFORE UPDATE ON UPSTREAM_REGISTRY_ACCESS_CONFIG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY_ACCESS_CONFIG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for UPSTREAM_REGISTRY_STORAGE_CONFIG table
DROP TRIGGER IF EXISTS trg_update_upstream_registry_storage_config;
CREATE TRIGGER trg_update_upstream_registry_storage_config
BEFORE UPDATE ON UPSTREAM_REGISTRY_STORAGE_CONFIG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY_STORAGE_CONFIG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for UPSTREAM_REGISTRY_CACHE_CONFIG table
DROP TRIGGER IF EXISTS trg_update_upstream_registry_cache_config;
CREATE TRIGGER trg_update_upstream_registry_cache_config
BEFORE UPDATE ON UPSTREAM_REGISTRY_CACHE_CONFIG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE UPSTREAM_REGISTRY_CACHE_CONFIG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for REGISTRY_NAMESPACE table
DROP TRIGGER IF EXISTS trg_update_registry_namespace;
CREATE TRIGGER trg_update_registry_namespace
BEFORE UPDATE ON REGISTRY_NAMESPACE
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE REGISTRY_NAMESPACE 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for REGISTRY_REPOSITORY table
DROP TRIGGER IF EXISTS trg_update_registry_repository;
CREATE TRIGGER trg_update_registry_repository
BEFORE UPDATE ON REGISTRY_REPOSITORY
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE REGISTRY_REPOSITORY 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for IMAGE_BLOB_META table
DROP TRIGGER IF EXISTS trg_update_image_blob_meta;
CREATE TRIGGER trg_update_image_blob_meta
BEFORE UPDATE ON IMAGE_BLOB_META
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE IMAGE_BLOB_META 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for IMAGE_TAG table
DROP TRIGGER IF EXISTS trg_update_image_tag;
CREATE TRIGGER trg_update_image_tag
BEFORE UPDATE ON IMAGE_TAG
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE IMAGE_TAG 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for IMAGE_MANIFEST table
DROP TRIGGER IF EXISTS trg_update_image_manifest;
CREATE TRIGGER trg_update_image_manifest
BEFORE UPDATE ON IMAGE_MANIFEST
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE IMAGE_MANIFEST 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- Trigger for IMAGE_REGISTRY_CACHE table
DROP TRIGGER IF EXISTS trg_update_image_registry_cache;
CREATE TRIGGER trg_update_image_registry_cache
BEFORE UPDATE ON IMAGE_REGISTRY_CACHE
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE IMAGE_REGISTRY_CACHE 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-- TODO: indexes have to created based on use-cases.

----------------- User account management ------------------------
CREATE TABLE IF NOT EXISTS USER_ACCOUNT (
    ID TEXT PRIMARY KEY DEFAULT (HEX(RANDOMBLOB(16))),
    USERNAME TEXT NOT NULL UNIQUE,
    EMAIL TEXT NOT NULL UNIQUE,
    PASSWORD TEXT NOT NULL,
    SALT TEXT NOT NULL,
    DISPLAY_NAME TEXT NOT NULL,
    LOCKED INTEGER NOT NULL DEFAULT 1,
    LOCKED_REASON INT DEFAULT 0,
    LOCKED_AT TIMESTAMP,
    DELETED INTEGER NOT NULL DEFAULT 0,
    FAILED_ATTEMPTS INTEGER NOT NULL DEFAULT 0,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS USER_ACCOUNT_RECOVERY(
  RECOVERY_UUID TEXT PRIMARY KEY,
  USER_ID TEXT NOT NULL UNIQUE, -- a user only have a password-recovery at a time.
  -- 1 - new account password set 2 -- forgot password 3 - password reset
  REASON_TYPE INTEGER NOT NULL DEFAULT 1 CHECK(REASON_TYPE IN (1, 2, 3)),
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (USER_ID) REFERENCES USER_ACCOUNT(ID) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS USER_ROLE(
    NAME TEXT PRIMARY KEY,
    CREATED_AT TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS USER_ROLE_ASSIGNMENT(
  USER_ID TEXT NOT NULL,
  ROLE_NAME TEXT NOT NULL,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (USER_ID), -- We enforce that user can have a single role at a time.
  FOREIGN KEY (USER_ID) REFERENCES USER_ACCOUNT(ID) ON DELETE CASCADE,
  FOREIGN KEY (ROLE_NAME) REFERENCES USER_ROLE(NAME) ON DELETE CASCADE
);

INSERT OR IGNORE INTO USER_ROLE(NAME) VALUES('Admin');
INSERT OR IGNORE INTO USER_ROLE(NAME) VALUES('Maintainer');
INSERT OR IGNORE INTO USER_ROLE(NAME) VALUES('Developer');
INSERT OR IGNORE INTO USER_ROLE(NAME) VALUES('Guest');

CREATE TABLE IF NOT EXISTS RESOURCE_ACCESS (
    ID TEXT PRIMARY KEY DEFAULT (HEX(RANDOMBLOB(16))),
    RESOURCE_TYPE TEXT NOT NULL CHECK(RESOURCE_TYPE IN ('namespace', 'repository', 'upstream_registry')),
    RESOURCE_ID TEXT NOT NULL,
    USER_ID TEXT NOT NULL,
    ACCESS_LEVEL TEXT NOT NULL CHECK(ACCESS_LEVEL IN ('maintainer', 'developer', 'guest')),
    GRANTED_BY TEXT NOT NULL, -- USER_ID who granted this access
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(RESOURCE_ID, USER_ID, RESOURCE_TYPE),
    FOREIGN KEY (USER_ID) REFERENCES USER_ACCOUNT(ID) ON DELETE CASCADE,
    FOREIGN KEY (GRANTED_BY) REFERENCES USER_ACCOUNT(ID) ON DELETE CASCADE
);

DROP TRIGGER IF EXISTS trg_user_account;
CREATE TRIGGER trg_user_account
BEFORE UPDATE ON USER_ACCOUNT
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE USER_ACCOUNT 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

DROP TRIGGER IF EXISTS trg_resource_access;
CREATE TRIGGER trg_resource_access
BEFORE UPDATE ON RESOURCE_ACCESS
FOR EACH ROW
WHEN NEW.UPDATED_AT = OLD.UPDATED_AT
BEGIN
    UPDATE RESOURCE_ACCESS 
    SET UPDATED_AT = CURRENT_TIMESTAMP 
    WHERE rowid = NEW.rowid;
END;

-------------------- authentication and authorization ----------------------------

CREATE TABLE IF NOT EXISTS OAUTH_SCOPE (
  SCOPE_NAME TEXT PRIMARY KEY,
  DESCRIPTION TEXT,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS OAUTH_SCOPE_ROLE_BINDING (
  SCOPE_NAME TEXT NOT NULL,
  ROLE_NAME TEXT NOT NULL,
  CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(SCOPE_NAME, ROLE_NAME)
);

CREATE TABLE IF NOT EXISTS OAUTH_AUTH_SESSION (
  SESSION_ID TEXT PRIMARY KEY,
  USER_ID TEXT NOT NULL,
  SCOPE_HASH_SHA256 TEXT NOT NULL,
  ISSUED_AT  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  EXPIRES_AT  TIMESTAMP NOT NULL,
  LAST_ACCESSED_AT  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  USER_AGENT TEXT NOT NULL,
  IP_ADDRESS TEXT NOT NULL,
  GRANT_TYPE TEXT NOT NULL -- -- "password", CURRENTLLY WE ONLY SUPPORTS PASSWORD
);

CREATE TABLE IF NOT EXISTS OAUTH_AUTH_SESSION_SCOPE (
  SESSION_ID TEXT NOT NULL,
  SCOPE TEXT NOT NULL,
  UNIQUE (SESSION_ID, SCOPE),
  FOREIGN KEY (SESSION_ID) REFERENCES OAUTH_AUTH_SESSION(SESSION_ID) ON DELETE CASCADE
);